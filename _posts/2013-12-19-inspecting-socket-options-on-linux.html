---
layout: post
title: "Inspecting socket options on Linux"
category: tech
tags:
 - Linux
 - TCP/IP
blogger: /2013/12/inspecting-socket-options-on-linux.html
---

<p>
The other day the question came up whether on Linux it is possible to determine the socket options for a TCP socket created by some running process. The <code>lsof</code> command actually has an option for that (<code>-T f</code>), but it is not supported on Linux. The reason is that socket options are not exposed via the <code>/proc</code> filesystem. This means that the only way to do this is using <a href="http://linux.die.net/man/1/strace"><code>strace</code></a>, <a href="http://linux.die.net/man/1/ltrace"><code>ltrace</code></a> or similar tools. This is problematic because they require some special setup and/or produce large amounts of data that one needs to analyze in order to get the desired information. Moreover, since they trace the invocation of the <a href="http://linux.die.net/man/2/setsockopt"><code>setsockopt</code></a> syscall, they have to be used at socket creation time and are useless if one needs to determine the options set on an already created socket.
</p>
<p>
In some cases, it is possible to determine the setting for particular socket options indirectly. E.g. the <code>netstat -to</code> command allows to determine if <code>SO_KEEPALIVE</code> is enabled on the socket for an established TCP connection: the <code>-o</code> option displays the currently active timer for each socket, and for established TCP connections with <code>SO_KEEPALIVE</code> set, this will be the keepalive timer. Obviously this is not a general solution since it only works for a small subset of all socket options.
</p>
<p>
To solve that issue, my original plan was to patch the Linux kernel to add the necessary information to the relevant files in <code>/proc/net</code> (<code>tcp</code>, <code>tcp6</code>, <code>udp</code>, <code>udp6</code>, etc.). However, it turned out that this is not a trivial change (such as adding a format specifier and argument to a <code>printf</code> call):
</p>
<ul>
<li>
The files in <code>/proc/net</code> are not meant to be human readable; they define an interface between the kernel and user space tools. This means that before adding information about socket options, one first has to carefully define the format in which this information is presented.
</li>
<li>
The code that formats the entries in the various files in <code>/proc/net</code> is scattered over multiple files and partially duplicated (see e.g. <code>tcp4_seq_show</code> in <code>net/ipv4/tcp_ipv4.c</code> and <code>tcp6_seq_show</code> in <code>net/ipv6/tcp_ipv6.c</code>, as well as the functions called by these two functions).
</li>
</ul>
<p>
That's why I finally settled on another idea, namely to write a kernel module that adds new files with the desired information to <code>/proc/net</code>. These files would be human readable (with a format similar to the output of the <code>netstat</code> command), so that one has more flexibility with respect to the presentation of the information in these files.
</p>
<p>
Fortunately the TCP/IP stack in Linux exports just enough of the relevant functions to enable reusing part of the code that generates the <code>/proc/net/tcp</code> and <code>/proc/net/tcp6</code> files, making it fairly easy to implement such a kernel module. The source code for the module is available as a project on Github called <a href="https://github.com/veithen/knetstat">knetstat</a>. After building and loading the <code>knetstat</code> module, two new files appear in <code>/proc/net</code>:
</p>
<pre><code>
$ cat /proc/net/tcpstat
Proto Recv-Q Send-Q Local Address           Foreign Address         State       Options
tcp        0      0 127.0.0.1:6010          0.0.0.0:*               LISTEN      SO_REUSEADDR=1,SO_KEEPALIVE=0
tcp        0      0 127.0.0.1:6011          0.0.0.0:*               LISTEN      SO_REUSEADDR=1,SO_KEEPALIVE=0
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      SO_REUSEADDR=1,SO_KEEPALIVE=0
tcp        0      0 127.0.0.1:6010          127.0.0.1:59038         ESTABLISHED SO_REUSEADDR=1,SO_KEEPALIVE=0
tcp        0      0 127.0.0.1:59038         127.0.0.1:6010          ESTABLISHED SO_REUSEADDR=0,SO_KEEPALIVE=1
tcp        0      0 192.168.1.15:22         192.168.1.6:57125       ESTABLISHED SO_REUSEADDR=1,SO_KEEPALIVE=1
tcp        0      0 192.168.1.15:22         192.168.1.6:57965       ESTABLISHED SO_REUSEADDR=1,SO_KEEPALIVE=1
$ cat /proc/net/tcp6stat
Proto Recv-Q Send-Q Local Address           Foreign Address         State       Options
tcp6       0      0 ::1:6010                :::*                    LISTEN      SO_REUSEADDR=1,SO_KEEPALIVE=0
tcp6       0      0 ::1:6011                :::*                    LISTEN      SO_REUSEADDR=1,SO_KEEPALIVE=0
tcp6       0      0 :::22                   :::*                    LISTEN      SO_REUSEADDR=1,SO_KEEPALIVE=0
</code></pre>
<p>
As implied by the name of the module, the format is indeed similar to the output of <code>netstat</code>, except of course for the last column with the socket options:
</p>
<pre><code>
$ netstat -tan
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 127.0.0.1:6010          0.0.0.0:*               LISTEN     
tcp        0      0 127.0.0.1:6011          0.0.0.0:*               LISTEN     
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN     
tcp        0      0 127.0.0.1:6010          127.0.0.1:59038         ESTABLISHED
tcp        0      0 127.0.0.1:59038         127.0.0.1:6010          ESTABLISHED
tcp        0      0 192.168.1.15:22         192.168.1.6:57125       ESTABLISHED
tcp        0      0 192.168.1.15:22         192.168.1.6:57965       ESTABLISHED
tcp6       0      0 ::1:6010                :::*                    LISTEN     
tcp6       0      0 ::1:6011                :::*                    LISTEN     
tcp6       0      0 :::22                   :::*                    LISTEN     
</code></pre>
<p>
Note that at the time of writing, knetstat only supports a small set of socket options and lacks support for socket types other than TCP. Check the <code>README.md</code> file for the current list of supported features.
</p>
